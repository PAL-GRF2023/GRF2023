<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coordinate Transformation Least Squares Calculator</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --light-color: #ecf0f1;
            --dark-color: #34495e;
            --success-color: #2ecc71;
            --warning-color: #f39c12;
            --spline-color: #9b59b6;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4edf5 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            padding: 20px 0;
            margin-bottom: 30px;
        }
        
        h1 {
            color: var(--primary-color);
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: var(--dark-color);
            font-size: 1.2rem;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-bottom: 30px;
        }
        
        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background: white;
            border-radius: 12px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.08);
            padding: 25px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.12);
        }
        
        .card-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--light-color);
        }
        
        .card-header i {
            font-size: 1.8rem;
            color: var(--secondary-color);
            margin-right: 15px;
        }
        
        .card-title {
            font-size: 1.5rem;
            color: var(--primary-color);
            font-weight: 600;
        }
        
        .upload-area {
            border: 3px dashed var(--secondary-color);
            border-radius: 10px;
            padding: 40px 20px;
            text-align: center;
            background-color: rgba(52, 152, 219, 0.05);
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }
        
        .upload-area:hover {
            background-color: rgba(52, 152, 219, 0.1);
            border-color: var(--primary-color);
        }
        
        .upload-icon {
            font-size: 3.5rem;
            color: var(--secondary-color);
            margin-bottom: 15px;
        }
        
        .upload-text {
            font-size: 1.2rem;
            color: var(--dark-color);
            margin-bottom: 10px;
        }
        
        .file-input {
            display: none;
        }
        
        .btn {
            display: inline-block;
            background: var(--secondary-color);
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            text-align: center;
            text-decoration: none;
        }
        
        .btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        .btn-block {
            display: block;
            width: 100%;
            margin-top: 15px;
        }
        
        .btn-success {
            background: var(--success-color);
        }
        
        .btn-success:hover {
            background: #27ae60;
        }
        
        .btn-warning {
            background: var(--warning-color);
        }
        
        .btn-warning:hover {
            background: #e67e22;
        }
        
        .btn-spline {
            background: var(--spline-color);
        }
        
        .btn-spline:hover {
            background: #8e44ad;
        }
        
        .results-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-top: 20px;
        }
        
        @media (max-width: 768px) {
            .results-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .result-item {
            background: var(--light-color);
            border-radius: 8px;
            padding: 15px;
            min-height: 150px;
        }
        
        .result-label {
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .download-btn {
            background: var(--primary-color);
            padding: 5px 10px;
            font-size: 0.85rem;
        }
        
        .download-btn:hover {
            background: #1a252f;
        }
        
        .matrix-container {
            max-height: 200px;
            overflow: auto;
            background: white;
            border-radius: 6px;
            padding: 10px;
            font-family: monospace;
            font-size: 0.9rem;
            white-space: pre;
            border: 1px solid #ddd;
        }
        
        .status {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            text-align: center;
            font-weight: 500;
        }
        
        .status.processing {
            background: rgba(243, 156, 18, 0.15);
            color: var(--warning-color);
            border: 1px solid var(--warning-color);
        }
        
        .status.success {
            background: rgba(46, 204, 113, 0.15);
            color: var(--success-color);
            border: 1px solid var(--success-color);
        }
        
        .status.error {
            background: rgba(231, 76, 60, 0.15);
            color: var(--accent-color);
            border: 1px solid var(--accent-color);
        }
        
        .status.spline {
            background: rgba(155, 89, 182, 0.15);
            color: var(--spline-color);
            border: 1px solid var(--spline-color);
        }
        
        footer {
            text-align: center;
            padding: 20px;
            color: var(--dark-color);
            font-size: 0.9rem;
            margin-top: 20px;
            border-top: 1px solid #ddd;
        }
        
        .parameters {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 15px;
        }
        
        .param-item {
            background: white;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        
        .param-label {
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 5px;
        }
        
        .param-value {
            font-family: monospace;
            font-size: 1.1rem;
            color: var(--secondary-color);
        }
        
        .file-example {
            background: rgba(52, 152, 219, 0.1);
            border-left: 4px solid var(--secondary-color);
            padding: 15px;
            border-radius: 0 8px 8px 0;
            margin: 15px 0;
            font-family: monospace;
            font-size: 0.95rem;
        }
        
        .example-header {
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 8px;
        }
        
        .transformation-settings {
            margin: 20px 0;
            padding: 15px;
            background: rgba(52, 152, 219, 0.08);
            border-radius: 8px;
            border: 1px solid var(--secondary-color);
        }
        
        .settings-title {
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }
        
        .settings-title i {
            margin-right: 8px;
            color: var(--secondary-color);
        }
        
        select, input[type="number"] {
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #ddd;
            font-size: 1rem;
            margin-top: 8px;
            width: 100%;
            background: white;
        }
        
        .settings-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        
        .settings-item {
            flex: 1;
            min-width: 200px;
        }
        
        .settings-label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--dark-color);
        }
        
        .spline-info {
            margin-top: 10px;
            padding: 10px;
            background: rgba(155, 89, 182, 0.1);
            border-radius: 6px;
            border-left: 3px solid var(--spline-color);
            font-size: 0.9rem;
            display: none;
        }
        
        .equation-display {
            margin-top: 15px;
            padding: 15px;
            background: rgba(44, 62, 80, 0.05);
            border-radius: 8px;
            border-left: 3px solid var(--primary-color);
            font-family: 'Cambria Math', 'Times New Roman', serif;
            font-size: 1.2rem;
            line-height: 1.8;
        }
        
        .equation-title {
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 8px;
        }
        
        .highlight {
            color: var(--secondary-color);
            font-weight: bold;
        }
        
        @media (max-width: 600px) {
            .equation-display {
                font-size: 1rem;
            }
            
            .settings-group {
                flex-direction: column;
            }
        }
        
        .spline-equation {
            color: var(--spline-color);
            font-weight: bold;
        }
        
        .spline-warning {
            margin-top: 10px;
            padding: 8px;
            background: rgba(243, 156, 18, 0.1);
            border-radius: 4px;
            font-size: 0.85rem;
            color: var(--warning-color);
            display: none;
        }
        
        .precision-warning {
            margin-top: 8px;
            font-size: 0.85rem;
            color: var(--warning-color);
        }
        
        .precision-example {
            margin-top: 5px;
            font-size: 0.85rem;
            color: var(--dark-color);
            font-family: monospace;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-calculator"></i> Coordinate Transformation Calculator</h1>
            <p class="subtitle">Upload coordinate data files to compute least squares transformation parameters between two coordinate systems. Select transformation model and precision settings.</p>
        </header>
        
        <div class="main-content">
            <div class="card">
                <div class="card-header">
                    <i class="fas fa-file-upload"></i>
                    <h2 class="card-title">Upload Coordinate Data</h2>
                </div>
                
                <div class="transformation-settings">
                    <div class="settings-title">
                        <i class="fas fa-sliders-h"></i> Transformation Settings
                    </div>
                    
                    <div class="settings-group">
                        <div class="settings-item">
                            <label class="settings-label" for="transformationType">Transformation Model</label>
                            <select id="transformationType">
                                <option value="1" selected>1st Order Polynomial (Affine)</option>
                                <option value="2">2nd Order Polynomial</option>
                                <option value="3">3rd Order Polynomial</option>
                                <option value="spline">Spline Transformation (Thin Plate)</option>
                            </select>
                        </div>
                        
                        <div class="settings-item">
                            <label class="settings-label" for="decimalDigits">Decimal Precision</label>
                            <input type="number" id="decimalDigits" min="0" max="15" value="6">
                            <div class="precision-example">Example: 1234.567890 (6 digits)</div>
                            <div class="precision-warning">Higher precision increases file size and may show insignificant digits.</div>
                        </div>
                    </div>
                    
                    <div class="spline-info" id="splineInfo">
                        <i class="fas fa-info-circle"></i> Spline transformation uses radial basis functions for non-linear deformation modeling. Requires at least 4 control points.
                    </div>
                    
                    <div class="equation-display">
                        <div class="equation-title">Transformation Equations:</div>
                        <div id="equationE">E<sub>2</sub> = a·E<sub>1</sub> + b·N<sub>1</sub> + c</div>
                        <div id="equationN">N<sub>2</sub> = d·E<sub>1</sub> + e·N<sub>1</sub> + f</div>
                    </div>
                    
                    <div class="spline-warning" id="splineWarning">
                        <i class="fas fa-exclamation-triangle"></i> Spline models with many points can be computationally intensive and may produce oscillations.
                    </div>
                </div>
                
                <div class="upload-area" id="dropArea">
                    <i class="fas fa-cloud-upload-alt upload-icon"></i>
                    <h3 class="upload-text">Drag & Drop Coordinate File Here</h3>
                    <p>or</p>
                    <input type="file" id="fileInput" class="file-input" accept=".txt,.csv">
                    <label for="fileInput" class="btn btn-block">Browse Files</label>
                </div>
                
                <div class="file-example">
                    <div class="example-header">File Format Example:</div>
                    <div>E1_1 N1_1 E2_1 N2_1</div>
                    <div>E1_2 N1_2 E2_2 N2_2</div>
                    <div>⋮  ⋮  ⋮  ⋮</div>
                    <div>E1_n N1_n E2_n N2_n</div>
                    <div class="example-footer">(Space or tab delimited text file)</div>
                </div>
                
                <div id="fileInfo" class="status" style="display: none;">
                    <i class="fas fa-info-circle"></i> <span id="fileName">File name</span> (<span id="pointCount">0</span> points)
                </div>
                
                <button id="processBtn" class="btn btn-block btn-success" disabled>
                    <i class="fas fa-play"></i> Process Least Squares Solution
                </button>
            </div>
            
            <div class="card">
                <div class="card-header">
                    <i class="fas fa-chart-line"></i>
                    <h2 class="card-title">Transformation Results</h2>
                </div>
                
                <div id="processingStatus" class="status processing" style="display: none;">
                    <i class="fas fa-spinner fa-spin"></i> Processing least squares solution... Please wait.
                </div>
                
                <div id="errorStatus" class="status error" style="display: none;">
                    <i class="fas fa-exclamation-triangle"></i> <span id="errorMessage"></span>
                </div>
                
                <div id="successStatus" class="status success" style="display: none;">
                    <i class="fas fa-check-circle"></i> Least squares solution computed successfully! Results ready for download.
                </div>
                
                <div id="splineStatus" class="status spline" style="display: none;">
                    <i class="fas fa-check-circle"></i> Spline transformation computed successfully! Results ready for download.
                </div>
                
                <div class="parameters">
                    <div class="param-item">
                        <div class="param-label">Reference Variance (s0)</div>
                        <div class="param-value" id="s0Result">-</div>
                    </div>
                    <div class="param-item">
                        <div class="param-label">Degrees of Freedom</div>
                        <div class="param-value" id="dofResult">-</div>
                    </div>
                    <div class="param-item">
                        <div class="param-label">Transformation Type</div>
                        <div class="param-value" id="transformationTypeResult">1st Order Polynomial</div>
                    </div>
                    <div class="param-item">
                        <div class="param-label">Parameters Count</div>
                        <div class="param-value" id="paramCountResult">6</div>
                    </div>
                    <div class="param-item">
                        <div class="param-label">Decimal Precision</div>
                        <div class="param-value" id="precisionResult">6 digits</div>
                    </div>
                </div>
                
                <div class="results-grid">
                    <div class="result-item">
                        <div class="result-label">
                            Parameters (X)
                            <button class="btn download-btn" id="downloadX">
                                <i class="fas fa-download"></i> Save
                            </button>
                        </div>
                        <div class="matrix-container" id="xResult">Ready after processing</div>
                    </div>
                    
                    <div class="result-item">
                        <div class="result-label">
                            Cofactor Matrix (Qxx)
                            <button class="btn download-btn" id="downloadQxx">
                                <i class="fas fa-download"></i> Save
                            </button>
                        </div>
                        <div class="matrix-container" id="qxxResult">Ready after processing</div>
                    </div>
                    
                    <div class="result-item">
                        <div class="result-label">
                            Covariance Matrix (Cxx)
                            <button class="btn download-btn" id="downloadCxx">
                                <i class="fas fa-download"></i> Save
                            </button>
                        </div>
                        <div class="matrix-container" id="cxxResult">Ready after processing</div>
                    </div>
                    
                    <div class="result-item">
                        <div class="result-label">
                            Residuals (V)
                            <button class="btn download-btn" id="downloadV">
                                <i class="fas fa-download"></i> Save
                            </button>
                        </div>
                        <div class="matrix-container" id="vResult">Ready after processing</div>
                    </div>
                </div>
                
                <div style="display: flex; gap: 15px; margin-top: 20px; flex-wrap: wrap;">
                    <button class="btn" id="downloadA" style="flex: 1; min-width: 200px;">
                        <i class="fas fa-download"></i> Save Design Matrix (A)
                    </button>
                    <button class="btn" id="downloadL" style="flex: 1; min-width: 200px;">
                        <i class="fas fa-download"></i> Save Observations (L)
                    </button>
                </div>
            </div>
        </div>
        
        <footer>
            <p>Least Squares Coordinate Transformation Calculator &copy; 2025 | For surveying and geospatial applications</p>
        </footer>
    </div>

    <script>
        // DOM elements
        const dropArea = document.getElementById('dropArea');
        const fileInput = document.getElementById('fileInput');
        const processBtn = document.getElementById('processBtn');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const pointCount = document.getElementById('pointCount');
        const processingStatus = document.getElementById('processingStatus');
        const errorStatus = document.getElementById('errorStatus');
        const successStatus = document.getElementById('successStatus');
        const splineStatus = document.getElementById('splineStatus');
        const errorMessage = document.getElementById('errorMessage');
        const transformationType = document.getElementById('transformationType');
        const decimalDigits = document.getElementById('decimalDigits');
        const equationE = document.getElementById('equationE');
        const equationN = document.getElementById('equationN');
        const splineInfo = document.getElementById('splineInfo');
        const splineWarning = document.getElementById('splineWarning');
        const transformationTypeResult = document.getElementById('transformationTypeResult');
        const paramCountResult = document.getElementById('paramCountResult');
        const precisionResult = document.getElementById('precisionResult');
        
        // Result elements
        const xResult = document.getElementById('xResult');
        const qxxResult = document.getElementById('qxxResult');
        const cxxResult = document.getElementById('cxxResult');
        const vResult = document.getElementById('vResult');
        const s0Result = document.getElementById('s0Result');
        const dofResult = document.getElementById('dofResult');
        
        // Download buttons
        const downloadX = document.getElementById('downloadX');
        const downloadQxx = document.getElementById('downloadQxx');
        const downloadCxx = document.getElementById('downloadCxx');
        const downloadV = document.getElementById('downloadV');
        const downloadA = document.getElementById('downloadA');
        const downloadL = document.getElementById('downloadL');
        
        // Global variables to store data
        let coordinateData = [];
        let results = null;
        let currentTransformation = '1'; // Default to 1st order polynomial
        let digits = 6; // Default decimal precision
        
        // Event listeners for drag and drop
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
        });
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, highlight, false);
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, unhighlight, false);
        });
        
        function highlight() {
            dropArea.style.borderColor = '#2c3e50';
            dropArea.style.backgroundColor = 'rgba(44, 62, 80, 0.05)';
        }
        
        function unhighlight() {
            dropArea.style.borderColor = '#3498db';
            dropArea.style.backgroundColor = 'rgba(52, 152, 219, 0.05)';
        }
        
        // Handle file drop
        dropArea.addEventListener('drop', handleDrop, false);
        
        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            
            if (files.length) {
                handleFiles(files);
            }
        }
        
        // Handle file selection
        fileInput.addEventListener('change', function() {
            handleFiles(this.files);
        });
        
        // Handle decimal digits change
        decimalDigits.addEventListener('change', function() {
            const value = parseInt(this.value);
            if (value < 0) this.value = 0;
            if (value > 15) this.value = 15;
            digits = parseInt(this.value);
            precisionResult.textContent = `${digits} digits`;
            
            // If results are already computed, update the display
            if (results) {
                displayResults();
            }
        });
        
        function handleFiles(files) {
            if (files.length === 0) return;
            
            const file = files[0];
            fileName.textContent = file.name;
            fileInfo.style.display = 'block';
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                parseFile(e.target.result);
            };
            
            reader.readAsText(file);
        }
        
        function parseFile(content) {
            coordinateData = [];
            const lines = content.trim().split('\n');
            
            // Skip header if first line contains non-numeric values
            const firstLine = lines[0].trim().split(/\s+/);
            const isHeader = isNaN(parseFloat(firstLine[0]));
            const startIndex = isHeader ? 1 : 0;
            
            for (let i = startIndex; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                // Handle different delimiters: space, tab, comma
                const parts = line.split(/[\s,;]+/).filter(part => part !== '');
                
                if (parts.length >= 4) {
                    const e1 = parseFloat(parts[0]);
                    const n1 = parseFloat(parts[1]);
                    const e2 = parseFloat(parts[2]);
                    const n2 = parseFloat(parts[3]);
                    
                    if (!isNaN(e1) && !isNaN(n1) && !isNaN(e2) && !isNaN(n2)) {
                        coordinateData.push({ e1, n1, e2, n2 });
                    }
                }
            }
            
            pointCount.textContent = coordinateData.length;
            processBtn.disabled = coordinateData.length < 3;
            
            if (coordinateData.length < 3) {
                showError(`Insufficient data points. At least 3 points required for transformation (found ${coordinateData.length}).`);
            } else {
                hideError();
                
                // Check if current transformation type is valid for the number of points
                validateTransformationType();
            }
        }
        
        function validateTransformationType() {
            const points = coordinateData.length;
            const type = currentTransformation;
            
            // Check minimum points requirements
            let isValid = true;
            let message = '';
            
            if (type === 'spline') {
                if (points < 4) {
                    isValid = false;
                    message = `Spline transformation requires at least 4 control points (found ${points}).`;
                }
            } else {
                const order = parseInt(type);
                const minPoints = {
                    1: 3,  // 6 parameters / 2 observations per point = 3 points
                    2: 6,  // 12 parameters / 2 = 6 points
                    3: 10  // 20 parameters / 2 = 10 points
                };
                
                if (points < minPoints[order]) {
                    isValid = false;
                    message = `${getOrderName(order)} transformation requires at least ${minPoints[order]} points (found ${points}).`;
                }
            }
            
            if (!isValid) {
                showError(message);
                processBtn.disabled = true;
            } else {
                hideError();
                processBtn.disabled = (points < 3);
            }
        }
        
        function getOrderName(order) {
            const suffixes = ['st', 'nd', 'rd', 'th'];
            return order + (suffixes[order-1] || 'th') + ' Order Polynomial';
        }
        
        function showError(message) {
            errorMessage.textContent = message;
            errorStatus.style.display = 'block';
            successStatus.style.display = 'none';
            splineStatus.style.display = 'none';
            processingStatus.style.display = 'none';
        }
        
        function hideError() {
            errorStatus.style.display = 'none';
        }
        
        function showProcessing() {
            processingStatus.style.display = 'block';
            successStatus.style.display = 'none';
            splineStatus.style.display = 'none';
            errorStatus.style.display = 'none';
        }
        
        function showSuccess(isSpline = false) {
            processingStatus.style.display = 'none';
            errorStatus.style.display = 'none';
            
            if (isSpline) {
                successStatus.style.display = 'none';
                splineStatus.style.display = 'block';
            } else {
                successStatus.style.display = 'block';
                splineStatus.style.display = 'none';
            }
        }
        
        // Update equations based on transformation type
        function updateEquations(type) {
            currentTransformation = type;
            transformationTypeResult.textContent = type === 'spline' ? 'Spline Transformation' : getOrderName(parseInt(type));
            
            if (type === 'spline') {
                splineInfo.style.display = 'block';
                splineWarning.style.display = coordinateData.length > 8 ? 'block' : 'none';
                equationE.innerHTML = 'E<sub>2</sub> = a<sub>0</sub> + a<sub>1</sub>E<sub>1</sub> + a<sub>2</sub>N<sub>1</sub> + Σw<sub>i</sub>·U(||P-P<sub>i</sub>||)';
                equationN.innerHTML = 'N<sub>2</sub> = b<sub>0</sub> + b<sub>1</sub>E<sub>1</sub> + b<sub>2</sub>N<sub>1</sub> + Σw<sub>i</sub>·U(||P-P<sub>i</sub>||)';
                equationE.classList.add('spline-equation');
                equationN.classList.add('spline-equation');
            } else {
                splineInfo.style.display = 'none';
                splineWarning.style.display = 'none';
                equationE.classList.remove('spline-equation');
                equationN.classList.remove('spline-equation');
                
                const order = parseInt(type);
                switch(order) {
                    case 1:
                        equationE.innerHTML = 'E<sub>2</sub> = a·E<sub>1</sub> + b·N<sub>1</sub> + c';
                        equationN.innerHTML = 'N<sub>2</sub> = d·E<sub>1</sub> + e·N<sub>1</sub> + f';
                        break;
                    case 2:
                        equationE.innerHTML = 'E<sub>2</sub> = a<sub>1</sub> + a<sub>2</sub>·E<sub>1</sub> + a<sub>3</sub>·N<sub>1</sub> + a<sub>4</sub>·E<sub>1</sub>N<sub>1</sub> + a<sub>5</sub>·E<sub>1</sub><sup>2</sup> + a<sub>6</sub>·N<sub>1</sub><sup>2</sup>';
                        equationN.innerHTML = 'N<sub>2</sub> = b<sub>1</sub> + b<sub>2</sub>·E<sub>1</sub> + b<sub>3</sub>·N<sub>1</sub> + b<sub>4</sub>·E<sub>1</sub>N<sub>1</sub> + b<sub>5</sub>·E<sub>1</sub><sup>2</sup> + b<sub>6</sub>·N<sub>1</sub><sup>2</sup>';
                        break;
                    case 3:
                        equationE.innerHTML = 'E<sub>2</sub> = a<sub>1</sub> + a<sub>2</sub>·E<sub>1</sub> + a<sub>3</sub>·N<sub>1</sub> + a<sub>4</sub>·E<sub>1</sub>N<sub>1</sub> + a<sub>5</sub>·E<sub>1</sub><sup>2</sup> + a<sub>6</sub>·N<sub>1</sub><sup>2</sup> + a<sub>7</sub>·E<sub>1</sub><sup>2</sup>N<sub>1</sub> + a<sub>8</sub>·E<sub>1</sub>N<sub>1</sub><sup>2</sup> + a<sub>9</sub>·E<sub>1</sub><sup>3</sup> + a<sub>10</sub>·N<sub>1</sub><sup>3</sup>';
                        equationN.innerHTML = 'N<sub>2</sub> = b<sub>1</sub> + b<sub>2</sub>·E<sub>1</sub> + b<sub>3</sub>·N<sub>1</sub> + b<sub>4</sub>·E<sub>1</sub>N<sub>1</sub> + b<sub>5</sub>·E<sub>1</sub><sup>2</sup> + b<sub>6</sub>·N<sub>1</sub><sup>2</sup> + b<sub>7</sub>·E<sub>1</sub><sup>2</sup>N<sub>1</sub> + b<sub>8</sub>·E<sub>1</sub>N<sub>1</sub><sup>2</sup> + b<sub>9</sub>·E<sub>1</sub><sup>3</sup> + b<sub>10</sub>·N<sub>1</sub><sup>3</sup>';
                        break;
                }
            }
            
            // Update parameter count display (will be finalized after computation)
            if (type === 'spline') {
                paramCountResult.textContent = coordinateData.length >= 4 ? (coordinateData.length + 3) * 2 + ' (approx.)' : '-';
            } else {
                const order = parseInt(type);
                const paramCounts = {1: 6, 2: 12, 3: 20};
                paramCountResult.textContent = paramCounts[order] || '-';
            }
            
            // Validate transformation with current data
            if (coordinateData.length > 0) {
                validateTransformationType();
            }
        }
        
        // Event listener for transformation type change
        transformationType.addEventListener('change', function() {
            updateEquations(this.value);
        });
        
        // Initialize equations with default order
        updateEquations(currentTransformation);
        
        // Process button click
        processBtn.addEventListener('click', function() {
            if (coordinateData.length < 3) {
                showError(`Insufficient data points. At least 3 points required for transformation (found ${coordinateData.length}).`);
                return;
            }
            
            // Check if enough points for the selected transformation type
            if (currentTransformation === 'spline') {
                if (coordinateData.length < 4) {
                    showError(`Spline transformation requires at least 4 control points (found ${coordinateData.length}).`);
                    return;
                }
            } else {
                const order = parseInt(currentTransformation);
                const minPoints = {
                    1: 3,  // 6 parameters / 2 observations per point = 3 points
                    2: 6,  // 12 parameters / 2 = 6 points
                    3: 10  // 20 parameters / 2 = 10 points
                };
                
                const requiredPoints = minPoints[order];
                if (coordinateData.length < requiredPoints) {
                    showError(`${getOrderName(order)} transformation requires at least ${requiredPoints} points (found ${coordinateData.length}).`);
                    return;
                }
            }
            
            // Get current precision setting
            digits = parseInt(decimalDigits.value);
            precisionResult.textContent = `${digits} digits`;
            
            showProcessing();
            
            // For spline transformations with many points, show a warning about computation time
            if (currentTransformation === 'spline' && coordinateData.length > 15) {
                console.warn("Large spline transformation - computation may take longer");
            }
            
            // Process with a slight delay to allow UI to update
            setTimeout(() => {
                try {
                    results = computeTransformation();
                    displayResults();
                    showSuccess(currentTransformation === 'spline');
                } catch (e) {
                    console.error(e);
                    showError(`Calculation error: ${e.message || e}`);
                }
            }, 100);
        });
        
        function computeTransformation() {
            if (currentTransformation === 'spline') {
                return computeSplineTransformation();
            } else {
                const order = parseInt(currentTransformation);
                return computePolynomialTransformation(order);
            }
        }
        
        function computePolynomialTransformation(order) {
            const n = coordinateData.length;
            const numObservations = 2 * n; // Each point has E and N observations
            
            // Determine number of parameters based on polynomial order
            let numParameters;
            switch(order) {
                case 1: numParameters = 6; break;  // a, b, c, d, e, f
                case 2: numParameters = 12; break; // a1-a6, b1-b6
                case 3: numParameters = 20; break; // a1-a10, b1-b10
                default: numParameters = 6;
            }
            
            // Build design matrix A (2n x numParameters)
            const A = new Array(numObservations);
            for (let i = 0; i < numObservations; i++) {
                A[i] = new Array(numParameters).fill(0);
            }
            
            // Build observation vector L (2n x 1)
            const L = new Array(numObservations).fill(0);
            
            // Fill A and L based on polynomial order
            for (let i = 0; i < n; i++) {
                const point = coordinateData[i];
                const rowE = 2 * i;     // Row for E observation
                const rowN = 2 * i + 1; // Row for N observation
                
                const E1 = point.e1;
                const N1 = point.n1;
                
                // Fill observation vector
                L[rowE] = point.e2;
                L[rowN] = point.n2;
                
                // Fill design matrix based on polynomial order
                switch(order) {
                    case 1: // 1st order (affine transformation)
                        // E2 = a*E1 + b*N1 + c
                        A[rowE][0] = E1; // a
                        A[rowE][1] = N1; // b
                        A[rowE][2] = 1;  // c
                        
                        // N2 = d*E1 + e*N1 + f
                        A[rowN][3] = E1; // d
                        A[rowN][4] = N1; // e
                        A[rowN][5] = 1;  // f
                        break;
                        
                    case 2: // 2nd order polynomial
                        // E2 = a1 + a2*E1 + a3*N1 + a4*E1*N1 + a5*E1^2 + a6*N1^2
                        A[rowE][0] = 1;     // a1
                        A[rowE][1] = E1;    // a2
                        A[rowE][2] = N1;    // a3
                        A[rowE][3] = E1*N1; // a4
                        A[rowE][4] = E1*E1; // a5
                        A[rowE][5] = N1*N1; // a6
                        
                        // N2 = b1 + b2*E1 + b3*N1 + b4*E1*N1 + b5*E1^2 + b6*N1^2
                        A[rowN][6] = 1;     // b1
                        A[rowN][7] = E1;    // b2
                        A[rowN][8] = N1;    // b3
                        A[rowN][9] = E1*N1; // b4
                        A[rowN][10] = E1*E1; // b5
                        A[rowN][11] = N1*N1; // b6
                        break;
                        
                    case 3: // 3rd order polynomial
                        // E2 = a1 + a2*E1 + a3*N1 + a4*E1*N1 + a5*E1^2 + a6*N1^2 + a7*E1^2*N1 + a8*E1*N1^2 + a9*E1^3 + a10*N1^3
                        A[rowE][0] = 1;            // a1
                        A[rowE][1] = E1;           // a2
                        A[rowE][2] = N1;           // a3
                        A[rowE][3] = E1*N1;        // a4
                        A[rowE][4] = E1*E1;        // a5
                        A[rowE][5] = N1*N1;        // a6
                        A[rowE][6] = E1*E1*N1;     // a7
                        A[rowE][7] = E1*N1*N1;     // a8
                        A[rowE][8] = E1*E1*E1;     // a9
                        A[rowE][9] = N1*N1*N1;     // a10
                        
                        // N2 = b1 + b2*E1 + b3*N1 + b4*E1*N1 + b5*E1^2 + b6*N1^2 + b7*E1^2*N1 + b8*E1*N1^2 + b9*E1^3 + b10*N1^3
                        A[rowN][10] = 1;            // b1
                        A[rowN][11] = E1;           // b2
                        A[rowN][12] = N1;           // b3
                        A[rowN][13] = E1*N1;        // b4
                        A[rowN][14] = E1*E1;        // b5
                        A[rowN][15] = N1*N1;        // b6
                        A[rowN][16] = E1*E1*N1;     // b7
                        A[rowN][17] = E1*N1*N1;     // b8
                        A[rowN][18] = E1*E1*E1;     // b9
                        A[rowN][19] = N1*N1*N1;     // b10
                        break;
                }
            }
            
            // Compute normal matrix N = A^T * A
            const N = new Array(numParameters);
            for (let i = 0; i < numParameters; i++) {
                N[i] = new Array(numParameters).fill(0);
                for (let j = 0; j < numParameters; j++) {
                    let sum = 0;
                    for (let k = 0; k < numObservations; k++) {
                        sum += A[k][i] * A[k][j];
                    }
                    N[i][j] = sum;
                }
            }
            
            // Compute right-hand side M = A^T * L
            const M = new Array(numParameters).fill(0);
            for (let i = 0; i < numParameters; i++) {
                let sum = 0;
                for (let k = 0; k < numObservations; k++) {
                    sum += A[k][i] * L[k];
                }
                M[i] = sum;
            }
            
            // Solve normal equations N * X = M
            const X = solveLinearSystem(N, M);
            
            // Compute residuals V = A * X - L
            const V = new Array(numObservations);
            for (let i = 0; i < numObservations; i++) {
                let sum = 0;
                for (let j = 0; j < numParameters; j++) {
                    sum += A[i][j] * X[j];
                }
                V[i] = sum - L[i];
            }
            
            // Compute reference variance s0
            let vTv = 0;
            for (let i = 0; i < numObservations; i++) {
                vTv += V[i] * V[i];
            }
            const dof = numObservations - numParameters; // Degrees of freedom
            
            // Check if we have enough degrees of freedom
            if (dof <= 0) {
                throw new Error(`Insufficient degrees of freedom. Need at least ${numParameters/2 + 1} points for this transformation.`);
            }
            
            const s0 = Math.sqrt(vTv / dof);
            
            // Compute cofactor matrix Qxx = inverse(N)
            const Qxx = invertMatrix(N);
            
            // Compute covariance matrix Cxx = s0^2 * Qxx
            const Cxx = new Array(numParameters);
            for (let i = 0; i < numParameters; i++) {
                Cxx[i] = new Array(numParameters);
                for (let j = 0; j < numParameters; j++) {
                    Cxx[i][j] = s0 * s0 * Qxx[i][j];
                }
            }
            
            return {
                A, L, V, X, Qxx, Cxx, s0, dof,
                numObservations, numParameters, order: order,
                transformationType: 'polynomial'
            };
        }
        
        function computeSplineTransformation() {
            const n = coordinateData.length;
            const numObservations = 2 * n;
            
            // For thin plate spline, we need:
            // - 3 global parameters (affine) for each coordinate: a0, a1, a2 for E2 and b0, b1, b2 for N2
            // - n local deformation parameters for each coordinate (one for each control point)
            // But we fix the last parameter to ensure solvability, so we use n-1 local parameters
            const numGlobalParams = 3; // affine parameters per coordinate
            const numLocalParams = n - 1; // local deformation parameters (fixing last one)
            
            const paramsPerCoord = numGlobalParams + numLocalParams;
            const numParameters = 2 * paramsPerCoord;
            
            // Build design matrix A (2n x numParameters)
            const A = new Array(numObservations);
            for (let i = 0; i < numObservations; i++) {
                A[i] = new Array(numParameters).fill(0);
            }
            
            // Build observation vector L (2n x 1)
            const L = new Array(numObservations).fill(0);
            
            // Precompute distances between all control points
            const distances = new Array(n);
            for (let i = 0; i < n; i++) {
                distances[i] = new Array(n);
                for (let j = 0; j < n; j++) {
                    if (i === j) {
                        distances[i][j] = 0;
                    } else {
                        const dx = coordinateData[i].e1 - coordinateData[j].e1;
                        const dy = coordinateData[i].n1 - coordinateData[j].n1;
                        const d = Math.sqrt(dx*dx + dy*dy);
                        distances[i][j] = d;
                    }
                }
            }
            
            // Thin Plate Spline radial basis function U(r) = r² log(r) with special handling for r=0
            function U(r) {
                if (r < 1e-10) return 0;
                return r * r * Math.log(r);
            }
            
            // Fill A and L
            for (let i = 0; i < n; i++) {
                const point = coordinateData[i];
                const rowE = 2 * i;     // Row for E observation
                const rowN = 2 * i + 1; // Row for N observation
                
                const E1 = point.e1;
                const N1 = point.n1;
                
                // Fill observation vector
                L[rowE] = point.e2;
                L[rowN] = point.n2;
                
                // Global affine parameters for E2
                A[rowE][0] = 1;    // a0 (constant term)
                A[rowE][1] = E1;   // a1 (coefficient for E1)
                A[rowE][2] = N1;   // a2 (coefficient for N1)
                
                // Global affine parameters for N2
                A[rowN][paramsPerCoord] = 1;    // b0 (constant term)
                A[rowN][paramsPerCoord + 1] = E1;   // b1 (coefficient for E1)
                A[rowN][paramsPerCoord + 2] = N1;   // b2 (coefficient for N1)
                
                // Local deformation parameters for E2 (fixing last parameter to 0)
                for (let j = 0; j < numLocalParams; j++) {
                    A[rowE][numGlobalParams + j] = U(distances[i][j]);
                }
                
                // Local deformation parameters for N2 (fixing last parameter to 0)
                for (let j = 0; j < numLocalParams; j++) {
                    A[rowN][paramsPerCoord + numGlobalParams + j] = U(distances[i][j]);
                }
            }
            
            // Compute normal matrix N = A^T * A
            const N = new Array(numParameters);
            for (let i = 0; i < numParameters; i++) {
                N[i] = new Array(numParameters).fill(0);
                for (let j = 0; j < numParameters; j++) {
                    let sum = 0;
                    for (let k = 0; k < numObservations; k++) {
                        sum += A[k][i] * A[k][j];
                    }
                    N[i][j] = sum;
                }
            }
            
            // Compute right-hand side M = A^T * L
            const M = new Array(numParameters).fill(0);
            for (let i = 0; i < numParameters; i++) {
                let sum = 0;
                for (let k = 0; k < numObservations; k++) {
                    sum += A[k][i] * L[k];
                }
                M[i] = sum;
            }
            
            // Solve normal equations N * X = M
            const X = solveLinearSystem(N, M);
            
            // Compute residuals V = A * X - L
            const V = new Array(numObservations);
            for (let i = 0; i < numObservations; i++) {
                let sum = 0;
                for (let j = 0; j < numParameters; j++) {
                    sum += A[i][j] * X[j];
                }
                V[i] = sum - L[i];
            }
            
            // Compute reference variance s0
            let vTv = 0;
            for (let i = 0; i < numObservations; i++) {
                vTv += V[i] * V[i];
            }
            const dof = numObservations - numParameters; // Degrees of freedom
            
            // Check if we have enough degrees of freedom
            if (dof <= 0) {
                throw new Error(`Insufficient degrees of freedom for spline transformation. Need more points or use a simpler model.`);
            }
            
            const s0 = Math.sqrt(vTv / dof);
            
            // Compute cofactor matrix Qxx = inverse(N)
            const Qxx = invertMatrix(N);
            
            // Compute covariance matrix Cxx = s0^2 * Qxx
            const Cxx = new Array(numParameters);
            for (let i = 0; i < numParameters; i++) {
                Cxx[i] = new Array(numParameters);
                for (let j = 0; j < numParameters; j++) {
                    Cxx[i][j] = s0 * s0 * Qxx[i][j];
                }
            }
            
            return {
                A, L, V, X, Qxx, Cxx, s0, dof,
                numObservations, numParameters, 
                numGlobalParams, numLocalParams,
                transformationType: 'spline'
            };
        }
        
        // Simple matrix inversion for small matrices (Gauss-Jordan elimination)
        function invertMatrix(matrix) {
            const n = matrix.length;
            // Create augmented matrix [A|I]
            const aug = new Array(n);
            for (let i = 0; i < n; i++) {
                aug[i] = new Array(2 * n).fill(0);
                for (let j = 0; j < n; j++) {
                    aug[i][j] = matrix[i][j];
                }
                aug[i][n + i] = 1;
            }
            
            // Gauss-Jordan elimination
            for (let i = 0; i < n; i++) {
                // Find pivot
                let maxRow = i;
                for (let j = i + 1; j < n; j++) {
                    if (Math.abs(aug[j][i]) > Math.abs(aug[maxRow][i])) {
                        maxRow = j;
                    }
                }
                
                // Swap rows if needed
                if (maxRow !== i) {
                    [aug[i], aug[maxRow]] = [aug[maxRow], aug[i]];
                }
                
                // Check for singular matrix
                const pivot = aug[i][i];
                if (Math.abs(pivot) < 1e-14) {
                    throw new Error("Matrix is singular or nearly singular");
                }
                
                // Scale row to make pivot 1
                for (let j = 0; j < 2 * n; j++) {
                    aug[i][j] /= pivot;
                }
                
                // Eliminate other rows
                for (let j = 0; j < n; j++) {
                    if (j !== i) {
                        const factor = aug[j][i];
                        for (let k = 0; k < 2 * n; k++) {
                            aug[j][k] -= factor * aug[i][k];
                        }
                    }
                }
            }
            
            // Extract inverse matrix
            const inverse = new Array(n);
            for (let i = 0; i < n; i++) {
                inverse[i] = new Array(n);
                for (let j = 0; j < n; j++) {
                    inverse[i][j] = aug[i][j + n];
                }
            }
            
            return inverse;
        }
        
        // Solve linear system using matrix inversion (for small systems)
        function solveLinearSystem(A, b) {
            try {
                const A_inv = invertMatrix(A);
                const n = A.length;
                const x = new Array(n).fill(0);
                
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        x[i] += A_inv[i][j] * b[j];
                    }
                }
                
                return x;
            } catch (e) {
                console.error("Error inverting matrix:", e);
                throw new Error("Could not solve the system. Matrix might be singular or nearly singular.");
            }
        }
        
        function displayResults() {
            if (!results) return;
            
            // Format parameters X with meaningful labels based on transformation type
            let xFormatted = '';
            if (results.transformationType === 'spline') {
                // Spline parameters
                const globalParamsE = ['a0', 'a1', 'a2'];
                const globalParamsN = ['b0', 'b1', 'b2'];
                
                xFormatted = '';
                // Global parameters for E2
                for (let i = 0; i < 3; i++) {
                    xFormatted += `${globalParamsE[i]} = ${results.X[i].toFixed(digits)}\n`;
                }
                
                // Local parameters for E2
                for (let i = 0; i < results.numLocalParams; i++) {
                    xFormatted += `wE_${i+1} = ${results.X[3 + i].toFixed(digits)}\n`;
                }
                
                xFormatted += '\n';
                
                // Global parameters for N2
                const offset = results.numGlobalParams + results.numLocalParams;
                for (let i = 0; i < 3; i++) {
                    xFormatted += `${globalParamsN[i]} = ${results.X[offset + i].toFixed(digits)}\n`;
                }
                
                // Local parameters for N2
                for (let i = 0; i < results.numLocalParams; i++) {
                    xFormatted += `wN_${i+1} = ${results.X[offset + 3 + i].toFixed(digits)}\n`;
                }
            } else {
                // Polynomial parameters
                switch(results.order) {
                    case 1:
                        const paramNames1 = ['a', 'b', 'c', 'd', 'e', 'f'];
                        xFormatted = results.X.map((val, i) => {
                            return `${paramNames1[i]} = ${val.toFixed(digits)}`;
                        }).join('\n');
                        break;
                    case 2:
                        const paramNames2E = ['a1', 'a2', 'a3', 'a4', 'a5', 'a6'];
                        const paramNames2N = ['b1', 'b2', 'b3', 'b4', 'b5', 'b6'];
                        xFormatted = results.X.map((val, i) => {
                            if (i < 6) {
                                return `${paramNames2E[i]} = ${val.toFixed(digits)}`;
                            } else {
                                return `${paramNames2N[i-6]} = ${val.toFixed(digits)}`;
                            }
                        }).join('\n');
                        break;
                    case 3:
                        const paramNames3E = ['a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'a10'];
                        const paramNames3N = ['b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'b10'];
                        xFormatted = results.X.map((val, i) => {
                            if (i < 10) {
                                return `${paramNames3E[i]} = ${val.toFixed(digits)}`;
                            } else {
                                return `${paramNames3N[i-10]} = ${val.toFixed(digits)}`;
                            }
                        }).join('\n');
                        break;
                }
            }
            xResult.textContent = xFormatted;
            
            // Format Qxx matrix
            const qxxFormatted = formatMatrix(results.Qxx, digits);
            qxxResult.textContent = qxxFormatted;
            
            // Format Cxx matrix
            const cxxFormatted = formatMatrix(results.Cxx, digits);
            cxxResult.textContent = cxxFormatted;
            
            // Format residuals V
            const vFormatted = results.V.map((val, i) => {
                return `Point ${Math.floor(i/2)+1} ${i%2===0?'E':'N'}: ${val.toFixed(digits)}`;
            }).join('\n');
            vResult.textContent = vFormatted;
            
            // Display s0 and DOF
            s0Result.textContent = results.s0.toFixed(digits);
            dofResult.textContent = results.dof;
        }
        
        function formatMatrix(matrix, precision) {
            if (!matrix || matrix.length === 0) return 'No data';
            
            // For large matrices, show a summary
            if (matrix.length > 15) {
                return `Matrix too large to display (${matrix.length}x${matrix[0].length}). Download to view full data.`;
            }
            
            // Find max width for each column for alignment
            const colWidths = new Array(matrix[0].length).fill(0);
            for (let i = 0; i < matrix.length; i++) {
                for (let j = 0; j < matrix[i].length; j++) {
                    const width = matrix[i][j].toFixed(precision).length;
                    if (width > colWidths[j]) colWidths[j] = width;
                }
            }
            
            // Format with proper alignment
            return matrix.map(row => 
                row.map((val, j) => {
                    const str = val.toFixed(precision);
                    const padding = ' '.repeat(Math.max(0, colWidths[j] - str.length + 2));
                    return str + padding;
                }).join('')
            ).join('\n');
        }
        
        // Download functions
        function downloadMatrix(filename, data) {
            let content = '';
            const precision = digits;
            
            if (Array.isArray(data) && Array.isArray(data[0])) {
                // 2D matrix
                content = data.map(row => 
                    row.map(val => val.toFixed(precision)).join('\t')
                ).join('\n');
            } else if (Array.isArray(data)) {
                // Vector
                content = data.map((val, i) => {
                    // Add parameter names based on transformation type and index
                    let paramName = `param_${i+1}`;
                    if (results.transformationType === 'spline') {
                        const globalParamsE = ['a0', 'a1', 'a2'];
                        const globalParamsN = ['b0', 'b1', 'b2'];
                        const perCoord = results.numGlobalParams + results.numLocalParams;
                        
                        if (i < 3) {
                            paramName = globalParamsE[i];
                        } else if (i < perCoord) {
                            paramName = `wE_${i-2}`;
                        } else if (i < perCoord + 3) {
                            paramName = globalParamsN[i - perCoord];
                        } else {
                            paramName = `wN_${i - perCoord - 2}`;
                        }
                    } else {
                        switch(results.order) {
                            case 1:
                                const names1 = ['a', 'b', 'c', 'd', 'e', 'f'];
                                if (i < names1.length) paramName = names1[i];
                                break;
                            case 2:
                                const names2E = ['a1', 'a2', 'a3', 'a4', 'a5', 'a6'];
                                const names2N = ['b1', 'b2', 'b3', 'b4', 'b5', 'b6'];
                                if (i < names2E.length) paramName = names2E[i];
                                else if (i < names2E.length + names2N.length) paramName = names2N[i - names2E.length];
                                break;
                            case 3:
                                const names3E = ['a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'a10'];
                                const names3N = ['b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'b10'];
                                if (i < names3E.length) paramName = names3E[i];
                                else if (i < names3E.length + names3N.length) paramName = names3N[i - names3E.length];
                                break;
                        }
                    }
                    return `${paramName}\t${val.toFixed(precision)}`;
                }).join('\n');
            } else {
                // Single value
                content = data.toFixed(precision).toString();
            }
            
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 0);
        }
        
        // Setup download buttons
        downloadX.addEventListener('click', () => {
            if (results) {
                const type = results.transformationType === 'spline' ? 'spline' : `order${results.order}`;
                downloadMatrix(`parameters_X_${type}.txt`, results.X);
            }
        });
        
        downloadQxx.addEventListener('click', () => {
            if (results) {
                const type = results.transformationType === 'spline' ? 'spline' : `order${results.order}`;
                downloadMatrix(`cofactor_Qxx_${type}.txt`, results.Qxx);
            }
        });
        
        downloadCxx.addEventListener('click', () => {
            if (results) {
                const type = results.transformationType === 'spline' ? 'spline' : `order${results.order}`;
                downloadMatrix(`covariance_Cxx_${type}.txt`, results.Cxx);
            }
        });
        
        downloadV.addEventListener('click', () => {
            if (results) {
                const type = results.transformationType === 'spline' ? 'spline' : `order${results.order}`;
                downloadMatrix(`residuals_V_${type}.txt`, results.V);
            }
        });
        
        downloadA.addEventListener('click', () => {
            if (results) {
                const type = results.transformationType === 'spline' ? 'spline' : `order${results.order}`;
                downloadMatrix(`design_matrix_A_${type}.txt`, results.A);
            }
        });
        
        downloadL.addEventListener('click', () => {
            if (results) {
                const type = results.transformationType === 'spline' ? 'spline' : `order${results.order}`;
                downloadMatrix(`observations_L_${type}.txt`, results.L);
            }
        });
        
        // Initialize with sample data for demonstration
        function initializeWithSampleData() {
            // Sample coordinate data (E1, N1, E2, N2)
            const sampleData = `
                Point E1 N1 E2 N2
                P1 1000.000 2000.000 5000.000 6000.000
                P2 1050.000 2030.000 5048.543 6031.456
                P3 1100.000 2080.000 5095.678 6080.123
                P4 1150.000 2120.000 5143.210 6120.432
                P5 1200.000 2180.000 5189.876 6179.543
                P6 1250.000 2230.000 5236.789 6229.876
                P7 1300.000 2290.000 5282.456 6289.123
                P8 1350.000 2340.000 5328.901 6339.456
            `;
            
            coordinateData = [];
            parseFile(sampleData);
            processBtn.disabled = false;
            
            // Show info about sample data
            fileName.textContent = "Sample Data (8 points)";
            pointCount.textContent = "8";
            fileInfo.style.display = 'block';
            
            // Initialize precision
            digits = parseInt(decimalDigits.value);
            precisionResult.textContent = `${digits} digits`;
        }
        
        // Initialize with sample data on page load
        window.addEventListener('DOMContentLoaded', initializeWithSampleData);
    </script>
</body>
</html>
